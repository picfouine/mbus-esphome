substitutions:
  device_name: warmte-meter-mbus
  friendly_name: MBus
  time_timezone: "Europe/Amsterdam"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32dev
  framework:
    type: arduino

external_components:
  - source:
      type: local
      path: custom_components
    
# Enable logging
logger:
  baud_rate: 0
  level: INFO 
  logs:
    sensor: INFO
    warmtemetermbus.sensor: INFO

# Enable Home Assistant API
api:
  encryption:
    key: "PsKaCvrdD8AjEdWsv7b32V2KGBf7kicJAqhE+/zU1H8="

ota:
  password: "e5264b2500ef5b812b82d4342c5a60f6"

wifi:
# Next two lines for building locally with ESPHome
#  ssid: "Unicorn"
#  password: "?" #password...
# Next two lines for building on Home Assistant OS, ESPHome
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Warmte-Meter-Mbus"
    password: "MHcfSqvZc6fe"

uart:
  baud_rate: 2400
  # WROOM Breadboard / PCB: TX 17, RX 16
  # tx_pin: 17
  # rx_pin: 16
  # WROVER PCB: TX 19, RX 18
  tx_pin: 19
  rx_pin: 18
  data_bits: 8
  parity: EVEN
  stop_bits: 1

switch:
  - platform: template
    name: MbusSwitch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: readmbus
    turn_on_action:
    - lambda: |-
        id(heatmetermbus).enableMbus();
    turn_off_action:
    - lambda: |-
        id(heatmetermbus).disableMbus();

button:
  - platform: restart
    name: "${friendly_name} Restart"
  - platform: factory_reset
    name: "${friendly_name} Factory Reset"    

interval:
  - interval: 8sec
    then:
      - lambda: |-
            id(heatmetermbus).readMbus();

heatmeter_mbus:
  id: heatmetermbus

# Time for uptime
time:
  - platform: homeassistant
    id: time_homeassistant
    timezone: "${time_timezone}"
    on_time_sync:
      - component.update: sensor_uptime_timestamp
  - platform: sntp
    id: time_sntp
    timezone: "${time_timezone}"

debug:
  update_interval: 5s

sensor:
  - platform: heatmeter_mbus
    name: "${friendly_name} T1"
    index: 6
    accuracy_decimals: 2
    unit_of_measurement: "°C"
    device_class: "temperature"
    icon: "mdi:thermometer"
  - platform: heatmeter_mbus
    name: "${friendly_name} T2"
    index: 7
    accuracy_decimals: 2
    unit_of_measurement: "°C"
    device_class: "temperature"
    icon: "mdi:thermometer"
  - platform: heatmeter_mbus
    name: "${friendly_name} Flow"
    index: 11
    accuracy_decimals: 0
    unit_of_measurement: "l/h"
    icon: "mdi:water"
    filters:
      - multiply: 0.001
  #Wifi signal
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 300s
    id: sensor_wifi_signal
  #Debug sensors
  - platform: debug
    free:
      name: "Heap Free"
    block:
      name: "Heap Max Block"
    loop_time:
      name: "Loop Time"
  #Uptime
  - platform: uptime
    id: sensor_uptime      
  - platform: template
    id: sensor_uptime_timestamp
    name: "${friendly_name} Uptime"
    device_class: "timestamp"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      static float timestamp = (
        id(time_homeassistant).utcnow().timestamp - id(sensor_uptime).state
      );
      return timestamp;
    entity_category: diagnostic
text_sensor:
  # IP address #
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP address"
      icon: "mdi:network-outline"
    ssid:
      name: "${friendly_name} Connected SSID"
    bssid:
      name: "${friendly_name} Connected BSSID"
  - platform: debug
    device:
      name: "Device Info"
    reset_reason:
      name: "Reset Reason"

# sensor:
#   - platform: heatmeter_mbus
#     id: heatmetermbus
#     heat_energy_e1:
#       name: heat_energy_e1
#     volume_v1:
#       name: volume_v1
#     energy_e8_inlet:
#       name: energy_e8_inlet
#     energy_e9_outlet:
#       name: energy_e9_outlet
#     operating_hours:
#       name: operating_hours
#     error_hour_counter:
#       name: error_hour_counter
#     t1_actual:
#       name: t1_actual
#     t2_actual:
#       name: t2_actual
#     t1_minus_t2:
#       name: t1_minus_t2
#     power_e1_over_e3:
#       name: power_e1_over_e3
#     power_max_month:
#       name: power_max_month
#     flow_v1_actual:
#       name: flow_v1_actual
#     flow_v1_max_month:
#       name: flow_v1_max_month
#     info_no_voltage_supply:
#       name: info_no_voltage_supply
#     info_t1_above_range_or_disconnected:
#       name: info_t1_above_range_or_disconnected
#     info_t2_above_range_or_disconnected:
#       name: info_t2_above_range_or_disconnected
#     info_t1_below_range_or_shorted:
#       name: info_t1_below_range_or_shorted
#     info_t2_below_range_or_shorted:
#       name: info_t2_below_range_or_shorted
#     info_invalid_temp_difference:
#       name: info_invalid_temp_difference
#     info_v1_air:
#       name: info_v1_air
#     info_v1_wrong_flow_direction:
#       name: info_v1_wrong_flow_direction
#     info_v1_greater_than_qs_more_than_hour:
#       name: info_v1_greater_than_qs_more_than_hour
#     heat_energy_e1_old:
#       name: heat_energy_e1_old
#     volume_v1_old:
#       name: volume_v1_old
#     energy_e8_inlet_old:
#       name: energy_e8_inlet_old
#     energy_e9_outlet_old:
#       name: energy_e9_outlet_old
#     power_max_year_old:
#       name: power_max_year_old
#     flow_v1_max_year_old:
#       name: flow_v1_max_year_old
#     log_year:
#       name: log_year
#       id: log_year
#     log_month:
#       name: log_month
#       id: log_month
#     log_day:
#       name: log_day
#       id: log_day
#     bus_voltage:
#       name: bus_voltage

# text_sensor:
#   - platform: template
#     id: log_date
#     name: log_date
#     lambda: |-
#       if (!id(log_day).has_state() || !id(log_month).has_state() || !id(log_year).has_state()) {
#         std::string notAvailableString("date not available");
#         return notAvailableString;
#       } else {
#         char stringBuffer[11];
#         for (int i = 0; i < 11; ++i) {
#           stringBuffer[i] = '\0';
#         }
#         sprintf(
#           stringBuffer, 
#           "%.0f-%.0f-20%.0f", 
#           round(id(log_day).state), 
#           round(id(log_month).state), 
#           round(id(log_year).state)
#         );
#         std::string dateString(stringBuffer);
#         return dateString;
#       }
